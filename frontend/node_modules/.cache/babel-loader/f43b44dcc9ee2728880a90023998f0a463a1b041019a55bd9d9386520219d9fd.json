{"ast":null,"code":"import _regeneratorRuntime from \"D:/split project/expense-tracker_fullstack-master/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"D:/split project/expense-tracker_fullstack-master/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// src/callWithRetry.ts\nfunction wait(ms) {\n  return new Promise(function (res) {\n    return setTimeout(res, ms);\n  });\n}\nvar MAX_NUMBER_OF_RETRIES = 5;\nfunction callWithRetry(_x) {\n  return _callWithRetry.apply(this, arguments);\n}\nfunction _callWithRetry() {\n  _callWithRetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fn) {\n    var attempt,\n      maxAttempts,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          attempt = _args.length > 1 && _args[1] !== undefined ? _args[1] : 1;\n          maxAttempts = _args.length > 2 && _args[2] !== undefined ? _args[2] : MAX_NUMBER_OF_RETRIES;\n          _context.prev = 2;\n          _context.next = 5;\n          return fn();\n        case 5:\n          return _context.abrupt(\"return\", _context.sent);\n        case 8:\n          _context.prev = 8;\n          _context.t0 = _context[\"catch\"](2);\n          if (!(attempt >= maxAttempts)) {\n            _context.next = 12;\n            break;\n          }\n          throw _context.t0;\n        case 12:\n          _context.next = 14;\n          return wait(Math.pow(2, attempt) * 100);\n        case 14:\n          return _context.abrupt(\"return\", callWithRetry(fn, attempt + 1, maxAttempts));\n        case 15:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[2, 8]]);\n  }));\n  return _callWithRetry.apply(this, arguments);\n}\nexport { callWithRetry };","map":{"version":3,"mappings":";;;AAAA,SAASA,KAAKC,IAAY;EACxB,OAAO,IAAIC,QAAQ;IAAA,OAAOC,WAAWC,KAAKH,EAAE,CAAC;EAAA;AAC/C;AAEA,IAAMI,wBAAwB;AAAA,SAQRC;EAAA;AAAA;AAAA;EAAAC,4EAAtB,iBACEC;IAAA;MAAAC;MAAAC;IAAA;MAAA;QAAA;UACAC,kEAAU;UACVF,sEAAcJ;UAAAO;UAAAA;UAAA,OAGCJ,GAAG;QAAA;UAAA;QAAA;UAAAI;UAAAA;UAAA,MAEZD,WAAWF;YAAAG;YAAA;UAAA;UAAA;QAAA;UAAAA;UAAA,OAGTZ,KAAKa,YAAKF,WAAU,GAAG;QAAA;UAAA,iCAEtBL,cAAcE,IAAIG,UAAU,GAAGF,WAAW;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CAErD;EAAA;AAAA","names":["wait","ms","Promise","setTimeout","res","MAX_NUMBER_OF_RETRIES","callWithRetry","_callWithRetry","fn","maxAttempts","_args","attempt","_context","Math"],"sources":["D:\\split project\\expense-tracker_fullstack-master\\frontend\\node_modules\\@clerk\\shared\\src\\callWithRetry.ts"],"sourcesContent":["function wait(ms: number) {\n  return new Promise(res => setTimeout(res, ms));\n}\n\nconst MAX_NUMBER_OF_RETRIES = 5;\n\n/**\n * Retry callback function every few hundred ms (with an exponential backoff\n * based on the current attempt) until the maximum attempts has reached or\n * the callback is executed successfully. The default number of maximum\n * attempts is 5 and retries are triggered when callback throws an error.\n */\nexport async function callWithRetry<T>(\n  fn: (...args: unknown[]) => Promise<T>,\n  attempt = 1,\n  maxAttempts = MAX_NUMBER_OF_RETRIES,\n): Promise<T> {\n  try {\n    return await fn();\n  } catch (e) {\n    if (attempt >= maxAttempts) {\n      throw e;\n    }\n    await wait(2 ** attempt * 100);\n\n    return callWithRetry(fn, attempt + 1, maxAttempts);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}