{"ast":null,"code":"import _slicedToArray from \"D:/split project/expense-tracker_fullstack-master/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// src/color.ts\nvar IS_HEX_COLOR_REGEX = /^#?([A-F0-9]{6}|[A-F0-9]{3})$/i;\nvar IS_RGB_COLOR_REGEX = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/i;\nvar IS_RGBA_COLOR_REGEX = /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+)(,\\s*\\d+(\\.\\d+)?)\\)$/i;\nvar IS_HSL_COLOR_REGEX = /^hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)$/i;\nvar IS_HSLA_COLOR_REGEX = /^hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%(,\\s*\\d+(\\.\\d+)?)*\\)$/i;\nvar isValidHexString = function isValidHexString(s) {\n  return !!s.match(IS_HEX_COLOR_REGEX);\n};\nvar isValidRgbaString = function isValidRgbaString(s) {\n  return !!(s.match(IS_RGB_COLOR_REGEX) || s.match(IS_RGBA_COLOR_REGEX));\n};\nvar isValidHslaString = function isValidHslaString(s) {\n  return !!s.match(IS_HSL_COLOR_REGEX) || !!s.match(IS_HSLA_COLOR_REGEX);\n};\nvar isRGBColor = function isRGBColor(c) {\n  return typeof c !== \"string\" && \"r\" in c;\n};\nvar isHSLColor = function isHSLColor(c) {\n  return typeof c !== \"string\" && \"h\" in c;\n};\nvar isTransparent = function isTransparent(c) {\n  return c === \"transparent\";\n};\nvar hasAlpha = function hasAlpha(color) {\n  return typeof color !== \"string\" && color.a != void 0 && color.a < 1;\n};\nvar CLEAN_HSLA_REGEX = /[hsla()]/g;\nvar CLEAN_RGBA_REGEX = /[rgba()]/g;\nvar stringToHslaColor = function stringToHslaColor(value) {\n  if (value === \"transparent\") {\n    return {\n      h: 0,\n      s: 0,\n      l: 0,\n      a: 0\n    };\n  }\n  if (isValidHexString(value)) {\n    return hexStringToHslaColor(value);\n  }\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n  if (isValidRgbaString(value)) {\n    return rgbaStringToHslaColor(value);\n  }\n  return null;\n};\nvar stringToSameTypeColor = function stringToSameTypeColor(value) {\n  value = value.trim();\n  if (isValidHexString(value)) {\n    return value.startsWith(\"#\") ? value : \"#\".concat(value);\n  }\n  if (isValidRgbaString(value)) {\n    return parseRgbaString(value);\n  }\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n  if (isTransparent(value)) {\n    return value;\n  }\n  return \"\";\n};\nvar colorToSameTypeString = function colorToSameTypeString(color) {\n  if (typeof color === \"string\" && (isValidHexString(color) || isTransparent(color))) {\n    return color;\n  }\n  if (isRGBColor(color)) {\n    return rgbaColorToRgbaString(color);\n  }\n  if (isHSLColor(color)) {\n    return hslaColorToHslaString(color);\n  }\n  return \"\";\n};\nvar hexStringToRgbaColor = function hexStringToRgbaColor(hex) {\n  hex = hex.replace(\"#\", \"\");\n  var r = parseInt(hex.substring(0, 2), 16);\n  var g = parseInt(hex.substring(2, 4), 16);\n  var b = parseInt(hex.substring(4, 6), 16);\n  return {\n    r: r,\n    g: g,\n    b: b\n  };\n};\nvar rgbaColorToRgbaString = function rgbaColorToRgbaString(color) {\n  var a = color.a,\n    b = color.b,\n    g = color.g,\n    r = color.r;\n  return color.a === 0 ? \"transparent\" : color.a != void 0 ? \"rgba(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\") : \"rgb(\".concat(r, \",\").concat(g, \",\").concat(b, \")\");\n};\nvar hslaColorToHslaString = function hslaColorToHslaString(color) {\n  var h = color.h,\n    s = color.s,\n    l = color.l,\n    a = color.a;\n  var sPerc = Math.round(s * 100);\n  var lPerc = Math.round(l * 100);\n  return color.a === 0 ? \"transparent\" : color.a != void 0 ? \"hsla(\".concat(h, \",\").concat(sPerc, \"%,\").concat(lPerc, \"%,\").concat(a, \")\") : \"hsl(\".concat(h, \",\").concat(sPerc, \"%,\").concat(lPerc, \"%)\");\n};\nvar hexStringToHslaColor = function hexStringToHslaColor(hex) {\n  var rgbaString = colorToSameTypeString(hexStringToRgbaColor(hex));\n  return rgbaStringToHslaColor(rgbaString);\n};\nvar rgbaStringToHslaColor = function rgbaStringToHslaColor(rgba) {\n  var rgbaColor = parseRgbaString(rgba);\n  var r = rgbaColor.r / 255;\n  var g = rgbaColor.g / 255;\n  var b = rgbaColor.b / 255;\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  var h, s;\n  var l = (max + min) / 2;\n  if (max == min) {\n    h = s = 0;\n  } else {\n    var d = max - min;\n    s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d * 60;\n        break;\n      case g:\n        h = ((b - r) / d + 2) * 60;\n        break;\n      default:\n        h = ((r - g) / d + 4) * 60;\n        break;\n    }\n  }\n  var res = {\n    h: Math.round(h),\n    s: s,\n    l: l\n  };\n  var a = rgbaColor.a;\n  if (a != void 0) {\n    res.a = a;\n  }\n  return res;\n};\nvar parseRgbaString = function parseRgbaString(str) {\n  var _str$replace$split$ma = str.replace(CLEAN_RGBA_REGEX, \"\").split(\",\").map(function (c) {\n      return Number.parseFloat(c);\n    }),\n    _str$replace$split$ma2 = _slicedToArray(_str$replace$split$ma, 4),\n    r = _str$replace$split$ma2[0],\n    g = _str$replace$split$ma2[1],\n    b = _str$replace$split$ma2[2],\n    a = _str$replace$split$ma2[3];\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n};\nvar parseHslaString = function parseHslaString(str) {\n  var _str$replace$split$ma3 = str.replace(CLEAN_HSLA_REGEX, \"\").split(\",\").map(function (c) {\n      return Number.parseFloat(c);\n    }),\n    _str$replace$split$ma4 = _slicedToArray(_str$replace$split$ma3, 4),\n    h = _str$replace$split$ma4[0],\n    s = _str$replace$split$ma4[1],\n    l = _str$replace$split$ma4[2],\n    a = _str$replace$split$ma4[3];\n  return {\n    h: h,\n    s: s / 100,\n    l: l / 100,\n    a: a\n  };\n};\nexport { isValidHexString, isValidRgbaString, isValidHslaString, isRGBColor, isHSLColor, isTransparent, hasAlpha, stringToHslaColor, stringToSameTypeColor, colorToSameTypeString, hexStringToRgbaColor };","map":{"version":3,"mappings":"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","names":["IS_HEX_COLOR_REGEX","IS_RGB_COLOR_REGEX","IS_RGBA_COLOR_REGEX","IS_HSL_COLOR_REGEX","IS_HSLA_COLOR_REGEX","isValidHexString","s","match","isValidRgbaString","isValidHslaString","isRGBColor","c","isHSLColor","isTransparent","hasAlpha","color","a","CLEAN_HSLA_REGEX","CLEAN_RGBA_REGEX","stringToHslaColor","value","h","l","hexStringToHslaColor","parseHslaString","rgbaStringToHslaColor","stringToSameTypeColor","trim","startsWith","parseRgbaString","colorToSameTypeString","rgbaColorToRgbaString","hslaColorToHslaString","hexStringToRgbaColor","hex","replace","r","parseInt","substring","g","b","sPerc","Math","round","lPerc","rgbaString","rgba","rgbaColor","max","min","d","res","str","split","map","Number","parseFloat","_str$replace$split$ma2","_str$replace$split$ma4"],"sources":["D:\\split project\\expense-tracker_fullstack-master\\frontend\\node_modules\\@clerk\\shared\\src\\color.ts"],"sourcesContent":["import type { Color, HslaColor, RgbaColor, TransparentColor } from '@clerk/types';\n\nconst IS_HEX_COLOR_REGEX = /^#?([A-F0-9]{6}|[A-F0-9]{3})$/i;\n\nconst IS_RGB_COLOR_REGEX = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/i;\nconst IS_RGBA_COLOR_REGEX = /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+)(,\\s*\\d+(\\.\\d+)?)\\)$/i;\n\nconst IS_HSL_COLOR_REGEX = /^hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)$/i;\nconst IS_HSLA_COLOR_REGEX = /^hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%(,\\s*\\d+(\\.\\d+)?)*\\)$/i;\n\nexport const isValidHexString = (s: string) => {\n  return !!s.match(IS_HEX_COLOR_REGEX);\n};\n\nexport const isValidRgbaString = (s: string) => {\n  return !!(s.match(IS_RGB_COLOR_REGEX) || s.match(IS_RGBA_COLOR_REGEX));\n};\n\nexport const isValidHslaString = (s: string) => {\n  return !!s.match(IS_HSL_COLOR_REGEX) || !!s.match(IS_HSLA_COLOR_REGEX);\n};\n\nexport const isRGBColor = (c: Color): c is RgbaColor => {\n  return typeof c !== 'string' && 'r' in c;\n};\n\nexport const isHSLColor = (c: Color): c is HslaColor => {\n  return typeof c !== 'string' && 'h' in c;\n};\n\nexport const isTransparent = (c: Color): c is TransparentColor => {\n  return c === 'transparent';\n};\n\nexport const hasAlpha = (color: Color): boolean => {\n  return typeof color !== 'string' && color.a != undefined && color.a < 1;\n};\n\nconst CLEAN_HSLA_REGEX = /[hsla()]/g;\nconst CLEAN_RGBA_REGEX = /[rgba()]/g;\n\nexport const stringToHslaColor = (value: string): HslaColor | null => {\n  if (value === 'transparent') {\n    return { h: 0, s: 0, l: 0, a: 0 };\n  }\n\n  if (isValidHexString(value)) {\n    return hexStringToHslaColor(value);\n  }\n\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n\n  if (isValidRgbaString(value)) {\n    return rgbaStringToHslaColor(value);\n  }\n\n  return null;\n};\n\nexport const stringToSameTypeColor = (value: string): Color => {\n  value = value.trim();\n  if (isValidHexString(value)) {\n    return value.startsWith('#') ? value : `#${value}`;\n  }\n\n  if (isValidRgbaString(value)) {\n    return parseRgbaString(value);\n  }\n\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n\n  if (isTransparent(value)) {\n    return value;\n  }\n  return '';\n};\n\nexport const colorToSameTypeString = (color: Color): string | TransparentColor => {\n  if (typeof color === 'string' && (isValidHexString(color) || isTransparent(color))) {\n    return color;\n  }\n\n  if (isRGBColor(color)) {\n    return rgbaColorToRgbaString(color);\n  }\n\n  if (isHSLColor(color)) {\n    return hslaColorToHslaString(color);\n  }\n\n  return '';\n};\n\nexport const hexStringToRgbaColor = (hex: string): RgbaColor => {\n  hex = hex.replace('#', '');\n  const r = parseInt(hex.substring(0, 2), 16);\n  const g = parseInt(hex.substring(2, 4), 16);\n  const b = parseInt(hex.substring(4, 6), 16);\n  return { r, g, b };\n};\n\nconst rgbaColorToRgbaString = (color: RgbaColor): string => {\n  const { a, b, g, r } = color;\n  return color.a === 0 ? 'transparent' : color.a != undefined ? `rgba(${r},${g},${b},${a})` : `rgb(${r},${g},${b})`;\n};\n\nconst hslaColorToHslaString = (color: HslaColor): string => {\n  const { h, s, l, a } = color;\n  const sPerc = Math.round(s * 100);\n  const lPerc = Math.round(l * 100);\n  return color.a === 0\n    ? 'transparent'\n    : color.a != undefined\n    ? `hsla(${h},${sPerc}%,${lPerc}%,${a})`\n    : `hsl(${h},${sPerc}%,${lPerc}%)`;\n};\n\nconst hexStringToHslaColor = (hex: string): HslaColor => {\n  const rgbaString = colorToSameTypeString(hexStringToRgbaColor(hex));\n  return rgbaStringToHslaColor(rgbaString);\n};\n\nconst rgbaStringToHslaColor = (rgba: string): HslaColor => {\n  const rgbaColor = parseRgbaString(rgba);\n  const r = rgbaColor.r / 255;\n  const g = rgbaColor.g / 255;\n  const b = rgbaColor.b / 255;\n\n  const max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  let h, s;\n  const l = (max + min) / 2;\n\n  if (max == min) {\n    h = s = 0;\n  } else {\n    const d = max - min;\n    s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);\n    switch (max) {\n      case r:\n        h = ((g - b) / d) * 60;\n        break;\n      case g:\n        h = ((b - r) / d + 2) * 60;\n        break;\n      default:\n        h = ((r - g) / d + 4) * 60;\n        break;\n    }\n  }\n\n  const res: HslaColor = { h: Math.round(h), s, l };\n  const a = rgbaColor.a;\n  if (a != undefined) {\n    res.a = a;\n  }\n  return res;\n};\n\nconst parseRgbaString = (str: string): RgbaColor => {\n  const [r, g, b, a] = str\n    .replace(CLEAN_RGBA_REGEX, '')\n    .split(',')\n    .map(c => Number.parseFloat(c));\n  return { r, g, b, a };\n};\n\nconst parseHslaString = (str: string): HslaColor => {\n  const [h, s, l, a] = str\n    .replace(CLEAN_HSLA_REGEX, '')\n    .split(',')\n    .map(c => Number.parseFloat(c));\n  return { h, s: s / 100, l: l / 100, a };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}